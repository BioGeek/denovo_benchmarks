"""
Script to convert predictions from the algorithm output format 
to the common output format.
"""

import argparse
import os
import re
from tqdm import tqdm
from pyteomics import mgf
from pyteomics.mztab import MzTab
from base import OutputMapperBase


class OutputMapper(OutputMapperBase):
    REPLACEMENTS = []
    PTM_PATTERN = r"([A-Z])([0-9.+-]+)" # find AAs with PTMs 
    N_TERM_MOD_PATTERN = r"^([0-9.+-]+)" # find N-term modifications

    def __init__(self, input_dir: str) -> None:
        """TODO."""
        fnames = [fname for fname in os.listdir(input_dir) if fname.endswith(".mgf")]
        self.file_names = [fname.split(".")[0] for fname in sorted(fnames)]

        file_paths = [
            os.path.join(input_dir, fname + ".mgf")
            for fname in self.file_names
        ]
        file_paths = sorted(file_paths)

        self.file_scan_ids = []
        for file_i, mgf_path in enumerate(file_paths):
            spectra = mgf.read(mgf_path)
            scan_ids = [spec["params"]["scans"] for spec in tqdm(spectra)]
            self.file_scan_ids.append(scan_ids)
        return
    
    def _transform_match_ptm(self, match: re.Match) -> str:
        """
        Transform representation of peptide substring matching
        the amino acid with PTM pattern.
        `PE+n_modP` -> `PE[+n_mod]P`
        
        Parameters
        ----------
        match : re.Match
            Substring matching the amino acid with PTM pattern.

        Returns
        -------
        transformed_match : str
            Transformed amino acid with PTM pattern representation.
        """
        aa, ptm = match.group(1), match.group(2)
        if ptm[0] not in ('-', '+'):
            ptm = "+" + ptm
        return f"{aa}[{ptm}]"
    
    def _transform_match_n_term_mod(self, match: re.Match) -> str:
        """
        Transform representation of peptide substring matching
        the N-term modification pattern.
        `+n_modPEP` -> `[+n_mod]-PEP`
        
        Parameters
        ----------
        match : re.Match
            Substring matching the N-term modification pattern.

        Returns
        -------
        transformed_match : str
            Transformed N-term modification pattern representation.
        """
        ptm = match.group(1)
        return f"[{ptm}]-"

    def _scan_index_to_filename_scan(self, scan_index: str) -> str:
        file_idx, scan_idx = scan_index.split(":")
        
        file_idx = int(file_idx) - 1
        filename = self.file_names[file_idx]
        
        scan_idx = int(scan_idx)
        scan_id = self.file_scan_ids[file_idx][scan_idx]
        return filename, scan_id
    
    def _parse_scores(self, scores: str) -> list[float]:
        """
        Convert per-token scores from a string of float scores 
        separated by ',' to a list of float numbers.
        """
        scores = scores.split(",")
        scores = list(map(float, scores))
        return scores

    def format_spectrum_id(self, spectrum_id: str) -> str:
        """
        TODO.
        Transform scan index generated by the algorithm to the common format
        `ms_run[i]:index=j` -> `filename:j`.
        """
        spectrum_id = re.sub("[a-z=_\[\]]", "", spectrum_id)

        filename, scan_id = self._scan_index_to_filename_scan(spectrum_id)
        spectrum_id = filename + ":" + scan_id
        return spectrum_id
    
    def format_sequence(self, sequence: str) -> str:
        """
        Convert peptide sequence to the common output data format 
        (ProForma with modifications represented 
        in the delta mass notation).

        Parameters
        ----------
        sequence : str
            Peptide sequence in the original algorithm output format.

        Returns
        -------
        transformed_sequence : str
            Peptide sequence in the common output data format.   
        """

        # direct (token-to-token) replacements
        for repl_args in self.REPLACEMENTS:
            sequence = sequence.replace(*repl_args)

        # transform PTM notation:
        # represent in ProForma delta mass notation PE[+ptm]P
        if re.search(self.PTM_PATTERN, sequence):
            sequence = re.sub(self.PTM_PATTERN, self._transform_match_ptm, sequence)

        # transform n-term modification notation
        # represent in ProForma delta mass notation [+n_term_mod]-PEP
        if re.search(self.N_TERM_MOD_PATTERN, sequence):
            sequence = re.sub(self.N_TERM_MOD_PATTERN, self._transform_match_n_term_mod, sequence)

        return sequence


parser = argparse.ArgumentParser()
parser.add_argument(
    "--output_path", required=True, help="The path to the algorithm predictions file."
)
parser.add_argument(
    "--input_dir", required=True, help="The dir with the input dataset .mgf files.",
)
args = parser.parse_args()

# Read predictions from output file
output_data = MzTab(args.output_path)
output_data = output_data.spectrum_match_table

# Rename columns to the expected column names if needed
output_data = output_data.rename(
    {
        "search_engine_score[1]": "score",
        "spectra_ref": "spectrum_id",
        "opt_ms_run[1]_aa_scores": "aa_scores",
    },
    axis=1,
)

# Transform data to the common output format
output_mapper = OutputMapper(input_dir=args.input_dir)
output_data = output_mapper.format_output(output_data)


# Save processed predictions to outputs.csv
# (the expected name for the algorithm output file)
output_data.to_csv("outputs.csv", index=False)
